# 1141229 課程筆記 - Dart 程式語言完整教學

## 目錄
1. [字串處理](#1-字串處理)
2. [變數宣告](#2-變數宣告)
3. [資料結構](#3-資料結構)
4. [Null Safety](#4-null-safety)
5. [Runes (Unicode)](#5-runes-unicode)
6. [運算子](#6-運算子)
7. [流程控制](#7-流程控制)
8. [例外處理](#8-例外處理)
9. [函式/方法](#9-函式方法)
10. [遞迴](#10-遞迴)
11. [變數作用域](#11-變數作用域)
12. [物件導向程式設計 (OOP)](#12-物件導向程式設計-oop)
13. [泛型 (Generics)](#13-泛型-generics)
14. [Library](#14-library)
15. [非同步程式設計](#15-非同步程式設計)
16. [並行處理](#16-並行處理-concurrency)
17. [Flutter 基礎](#17-flutter-基礎)

---

## 1. 字串處理

### Regular Expression (正規表達式)
```dart
String s01 = "abc1defg2hijk";
var list1 = s01.split(RegExp(r"\d"));  // 用數字分割
print(list1);  // [abc, defg, hijk]
```

### StringBuffer (字串緩衝區)
```dart
StringBuffer s02 = StringBuffer();
s02.writeln('Test');           // 寫入並換行
s02.writeAll(['x','y','z']);   // 寫入陣列
s02.write(100);                // 寫入數字
s02.writeCharCode(65);         // 寫入字元碼 (A)
print(s02);
```

### 數字/字串轉換
```dart
var int1 = int.parse("123");          // String -> int
var double1 = double.parse("33.3");   // String -> double
String str1 = x.toString();           // int -> String
String str2 = pi.toStringAsFixed(2);  // double -> String (保留2位小數)
```

---

## 2. 變數宣告

### 變數類型比較

| 關鍵字 | 說明 | 特性 |
|--------|------|------|
| `var` | 自動推論類型 | 一旦賦值，類型固定 |
| `dynamic` | 動態類型 | 可隨時改變類型 |
| `const` | 編譯期常數 | 必須在編譯時確定值 |
| `final` | 執行期常數 | 可在執行時賦值，但只能賦值一次 |
| `int?` | 可為 null 的整數 | Null Safety 語法 |

### 範例
```dart
double? pi1;        // 可為 null
print(pi1);         // null

var pi2 = 3.14159;  // 自動推論為 double
// pi2 = "3.14159"; // Error! 類型已固定

dynamic pi3 = 3.14159;
pi3 = "3.14159";    // OK! dynamic 可以改變類型

const pi5 = 3.14159;  // 編譯期常數
// pi5 = 3.14;        // Error!

final name;
name = 'Bob';
// name = 'Alice';    // Error! final 只能賦值一次

// num 可以是 int 或 double
num pi6 = 3;
pi6 = 3.14;
```

---

## 3. 資料結構

### List (有序陣列)
```dart
// 宣告方式
var list1 = [1, 2, 3];           // List<int>
List list2 = [1, 2, 3];          // List<dynamic>
List<int> list3 = [1, 2, 3];     // 明確宣告類型
var list4 = List.filled(3, 0);   // 建立固定長度 List

// 常數 List
var constantList = const [1, 2, 3];
// constantList[1] = 1;  // Error! 不可修改

// 常用操作
list1.add(4);              // 新增
list1.remove(4);           // 移除
list1[0] = 55;             // 修改
list1.contains(6);         // 檢查是否包含
list1.reversed;            // 反轉 (回傳 Iterable)
list1.shuffle();           // 隨機排序

// 排序
list1.sort();                                    // 預設排序
list1.sort((a,b) => a.length.compareTo(b.length));  // 自訂排序

// 合併
var list1718 = list17 + list18;

// 2D List
List<List<int>> A = [];
A.add([1, 2, 3]);

// 篩選
var n = [1, 2, 3, 4, 5];
n.where((i) => i.isOdd).forEach((i) => print(i));  // 1 3 5
```

### Set (集合 - 不重複)
```dart
var set1 = {1, 2, 3};       // Set<int>
var set3 = <int>{};         // 空 Set

set1.add(3);                // 重複元素不會加入
print(set1.length);         // 仍然是 3

// 集合運算
set4.difference(set5);      // 差集
set4.intersection(set5);    // 交集
set4.union(set6);           // 聯集

// 轉換為 List
List x = Set<String>.from(set4).toList();
```

### Map (鍵值對)
```dart
// 宣告方式
var g1 = {'first': 'A', 'second': 'B'};
var g2 = Map();
g2['first'] = 'A';

// 常數 Map
Map<int, String> constantMap = const {1: 'A', 2: 'B'};

// 操作
g3['fourth'] = 'D';         // 新增/修改
print(g3['third']);         // 讀取
m1.addAll(m2);              // 合併

// 遍歷
y.forEach((k, v) => print('Key:$k, value:$v'));
```

### Queue (佇列)
```dart
import 'dart:collection';

Queue q1 = Queue();
q1.addAll([10, 20, 30]);
q1.addFirst(5);
q1.addLast(40);
q1.removeFirst();
```

---

## 4. Null Safety

### 基本概念
```dart
int x;      // x 是 non-nullable
int? y;     // y 是 nullable (可為 null)

// x = null;  // Error!
y = null;    // OK

// 使用 nullable 變數前需要檢查
if (y != null) {
  x = y;     // OK
}
x = y!;      // 使用 ! 表示確定不是 null (null check)
```

### Nullable List
```dart
List<int>? b;           // List 本身可為 null
List<int?> c = [1, 2, null];  // List 元素可為 null
```

### late 關鍵字
```dart
class A {
  late int aa;  // 延遲初始化
}
```

### Null-aware 運算子
```dart
String? value1;
print(value1?.toLowerCase());     // 如果 value1 為 null，回傳 null

var a1 = 123;
print(a1 ??= 456);  // 如果 a1 為 null，賦值 456
print(a1 ?? 456);   // 如果 a1 為 null，使用 456
```

---

## 5. Runes (Unicode)

```dart
// Unicode 表示法
Runes heart = Runes('\u2665');
Runes laugh = Runes('\u{1f600}');
print(String.fromCharCodes(heart));  // ♥

String greeting = '\u4f60\u597d';
print(greeting);  // 你好

// 取得字元碼
String x = 'Runes';
print(x.codeUnitAt(0));  // 82
print(x.codeUnits);      // [82, 117, 110, 101, 115]
```

---

## 6. 運算子

### 算術運算子
| 運算子 | 說明 | 範例 |
|--------|------|------|
| `+` `-` `*` `/` | 四則運算 | |
| `~/` | 整數除法 | `5 ~/ 3` = 1 |
| `%` | 取餘數 | `5 % 3` = 2 |
| `++` `--` | 遞增/遞減 | |

### 位元運算子
| 運算子 | 說明 |
|--------|------|
| `&` | AND |
| `\|` | OR |
| `^` | XOR |
| `~` | NOT |
| `<<` | 左移 |
| `>>` | 右移 |

### 條件運算子
```dart
// 三元運算子
int b = a > 9 ? 99 : 100;

// ?? 運算子 (null coalescing)
final result = user ?? "root";  // 如果 user 為 null，使用 "root"

// ??= 運算子
k ??= 5;  // 如果 k 為 null，賦值 5
```

### Spread 運算子
```dart
var list1 = [1, 2, 3];
var list3 = [0, ...list1];  // [0, 1, 2, 3]

// Null-aware spread
List<int>? c1;
a = [...a, ...?c1];  // 如果 c1 為 null，不會報錯
```

### Cascade 運算子 (..)
```dart
var student = Student()
  ..id = 1
  ..name = 'Candy'
  ..classRoomName = '3A'
  ..Greeting();
```

### 類型檢查
```dart
if (s1 is int) print('s1 is integer type.');
if (s1 is! String) print('s1 is not String type.');

// 類型轉換
String myString = s1 as String;
```

---

## 7. 流程控制

### 選擇結構
```dart
// if-else
if (score < 60) {
  print("So bad...");
} else if (score >= 60 && score < 80) {
  print("Not bad~");
} else {
  print("Good job!");
}

// switch
switch (command) {
  case 'CLOSED': print("Closed!"); break;
  case 'OPEN': print("Open!"); break;
  default: print('UNKNOWN...');
}
```

### 迴圈結構
```dart
// for 迴圈
for (int x = 0; x < 5; x++) {
  print('x=$x');
}

// for-in 迴圈
for (var j in n) {
  print(j);
}

// forEach
n.forEach((i) => print(i));

// while 迴圈
while (k <= 10) {
  sum += k;
  k++;
}

// do-while 迴圈
do {
  print('x=$x');
} while (x < 5);

// break 和 continue
for (int i = 0; i < 10; i++) {
  if (i == 2) continue;  // 跳過本次
  if (i == 5) break;     // 跳出迴圈
  print('i=$i');
}
```

### 標準輸入/輸出
```dart
import 'dart:io';

stdout.write('請輸入總金額=');
m = int.parse(stdin.readLineSync()!);
```

---

## 8. 例外處理

### try-catch-finally
```dart
try {
  print(1 / 0);
} catch (e) {
  print(e);
} finally {
  print('Over!');
}
```

### 拋出例外
```dart
test1(int age) {
  if (age < 0) {
    throw FormatException();
  }
}
```

### 自訂例外
```dart
class AmountException implements Exception {
  static String s1 = 'Amount should be greater than zero!';
}

withDraw(int amount) {
  if (amount < 0) {
    throw AmountException();
  }
}

void main() {
  try {
    withDraw(-200);
  } on AmountException {
    print(AmountException.s1);
  }
}
```

---

## 9. 函式/方法

### 基本宣告
```dart
// 標準寫法
int add1(int a, int b) {
  return a + b;
}

// 箭頭函式
int add2(a, b) => a + b;

// 無回傳值
void printMsg() => print('Hello!');
```

### 選擇性參數
```dart
// 位置選擇性參數 (用 [])
void p3(int a, int b, [int c = 99]) => print(a + b + c);
p3(1, 2);      // c 使用預設值 99
p3(1, 2, 3);   // c = 3

// 具名選擇性參數 (用 {})
void p4(int a, int b, {int c = 99}) => print(a + b + c);
p4(1, 2);         // c 使用預設值 99
p4(1, 2, c: 3);   // c = 3

// required 必要參數
sayHello({required String name}) => print("Hello, $name");
```

### 函式作為參數
```dart
void test(Function fool) {
  fool();
}

test(() => print('Test'));
```

### typedef (函式類型別名)
```dart
typedef Calculate = int Function(int n1, int n2);

int test2(Calculate calc) {
  return calc(20, 30);
}

void main() {
  var a = test2((n1, n2) => n1 + n2);
  print(a);  // 50
}
```

---

## 10. 遞迴

```dart
// 階乘
int Fact(int n) {
  if (n <= 1) return 1;
  else return n * Fact(n - 1);
}

// 費波那契數列
int Fib(int n) {
  if (n <= 1) return n;
  else return Fib(n - 1) + Fib(n - 2);
}
```

---

## 11. 變數作用域

```dart
int a = 1;  // 全域變數

fun1() {
  var c = 3;  // 區域變數
}

void fun2() {
  var d = 4;
  // print('$c');  // Error: c 在這裡看不到
}

void main() {
  var b = 2;
  print('$a');    // OK: 全域變數
  // print('$d'); // Error: d 在這裡看不到
}
```

---

## 12. 物件導向程式設計 (OOP)

### 類別基礎
```dart
class Circle {
  final pi = 3.14159;
  int r = 0;

  Circle(int q) { r = q; }  // 建構子

  int area() => r * r;
  double vol() => 4 / 3 * r * r * r;
}

void main() {
  Circle c1 = Circle(5);
  print(c1.area());
}
```

### 私有成員 (使用 _ 前綴)
```dart
// car.dart
class Car {
  late int _a;   // 私有成員
  int _b = 2;

  Car(x) { _a = x; }

  // Getter/Setter
  set setA(v) => _a = v;
  int get getA => _a;
}

// 在其他檔案中
// print(c1._a);  // Error! 無法存取私有成員
print(c1.getA);   // OK
```

### 繼承 (extends)
```dart
class A {
  A() { print('In parent!'); }
}

class B extends A {
  B() { print('In child!'); }
}

// 呼叫父類別建構子
class B extends A {
  B(String ss) : super(ss) { print('In child!'); }
}

// 覆寫方法
class Dog extends Animal {
  @override
  void eat() => print('Dog can eat.');
}
```

### 具名建構子
```dart
class Cat {
  late String name;
  late String color;

  Cat(this.name, this.color);
  Cat.orange(this.name) { color = 'Orange'; }
  Cat.black(this.name) { color = 'Black'; }
  Cat.fromJson(Map<String, dynamic> json1) {
    this.name = json1['name'];
    this.color = json1['color'];
  }
}

void main() {
  print(Cat('nora', 'white'));
  print(Cat.orange('nora'));
  print(Cat.fromJson({'name': 'nora', 'color': 'Grey'}));
}
```

### 初始化列表
```dart
class Point {
  final sum, factor;
  Point(x, y) : sum = x + y, factor = x / y;
}
```

### 重導向建構子
```dart
class Point {
  double x, y;
  Point(this.x, this.y);
  Point.alongXAxis(double x) : this(x, 0);  // 重導向到主建構子
}
```

### 常數建構子
```dart
class Student {
  final String name;
  final int age;
  const Student(this.name, this.age);
}

void main() {
  var s3 = const Student('Ada', 22);
  var s4 = const Student('Ada', 22);
  print(identical(s3, s4));  // true (同一個實例)
}
```

### 工廠建構子
```dart
class Person {
  String name;
  static final Map<String, Person> _nameCache = {};

  Person(this.name);

  factory Person.withName(String name) {
    if (_nameCache.containsKey(name)) {
      return _nameCache[name]!;
    } else {
      final p = Person(name);
      _nameCache[name] = p;
      return p;
    }
  }
}
```

### Singleton 模式
```dart
class S {
  static final S s1 = S._internal();
  S._internal();
  factory S() => s1;
}

void main() {
  var s1 = S();
  var s2 = S();
  print(identical(s1, s2));  // true
}
```

### 運算子重載
```dart
class Vector {
  num x, y;
  Vector(this.x, this.y);

  operator +(Vector v) => Vector(x + v.x, y + v.y);
  operator -(Vector v) => Vector(x - v.x, y - v.y);
}
```

### 列舉 (Enumeration)
```dart
enum Colors { red, green, blue }

void main() {
  final color = Colors.red;
  switch (color) {
    case Colors.red: print('Red'); break;
    case Colors.green: print('Green'); break;
    case Colors.blue: print('Blue'); break;
  }
  print(Colors.values);     // [Colors.red, Colors.green, Colors.blue]
  print(Colors.red.index);  // 0
}
```

### 抽象類別
```dart
abstract class Animal {
  void talk();  // 抽象方法
  void growl() => print('grrrr');  // 具體方法
}

class Cat extends Animal {
  @override
  void talk() => print('Meow');
}
```

### Sealed Class
```dart
// 只能在同一檔案內被繼承
sealed class SealedStatus {
  void display() {}
}

class Init extends SealedStatus {
  @override
  void display() => print('Initializing...');
}
```

### Interface (implements)
```dart
abstract class A { fnA(); }
abstract class B { fnB(); }

class C implements A, B {
  @override
  fnA() => print('A');
  @override
  fnB() => print('B');
}
```

### Mixins
```dart
mixin Swim {
  void swim() => print('Swim');
}

mixin Fly {
  void fly() => print('Fly');
}

class Duck extends Bird with Swim, Fly {}

// mixin on: 限制 mixin 只能用在特定類別
mixin Hunt on Reptile {
  void hunt(String food) { ... }
}
```

### Static 成員
```dart
class Cons {
  static const name = 'abc';
  static sayHello() {
    print('Hello, this is ${Cons.name}');
  }
}

void main() {
  Cons.sayHello();
  print(Cons.name);
}
```

---

## 13. 泛型 (Generics)

### 基本用法
```dart
class Test<T> {
  T? obj;
  Test(T obj) { this.obj = obj; }
  T? getObject() => this.obj;
}

void main() {
  var t1 = Test<String>('Hello, world!');
  var t2 = Test<double>(3.14159);
}
```

### 限制泛型類型
```dart
class Point<T extends num> {
  T x, y;
  Point(this.x, this.y);
}
```

### 泛型函式
```dart
T printFirst<T>(List<T> lst) {
  T first = lst[0];
  print(first);
  return first;
}
```

---

## 14. Library

### 系統函式庫
```dart
import 'dart:math';
import 'dart:io';
import 'dart:collection';
```

### 自訂函式庫
```dart
// 絕對路徑
import 'file:///C:/path/to/util.dart';

// 相對路徑
import './util1/util1.dart';
import 'util2.dart';
```

### 別名與篩選
```dart
// 使用別名
import './math_util.dart' as mUtil;
print(mUtil.sum(10, 20));

// 只匯入特定函式
import './math_util.dart' as mUtil show sum;

// 排除特定函式
import './math_util.dart' as mUtil hide sum;
```

### 匯出多個檔案
```dart
// utils.dart
export 'math1.dart';
export 'math2.dart';
export 'math3.dart';

// main.dart
import './utils/utils.dart';
```

---

## 15. 非同步程式設計

### async/await
```dart
Future<String> getData() async {
  var response = await http.get(Uri.parse(url));
  return response.body;
}

void main() async {
  await getData().then((msg) => print(msg));
  print('Done!');
}
```

### Future
```dart
// Future.value
Future<int> futureWait() => Future.value(10);

// Future.delayed
Future<String> futureDelayed() {
  return Future.delayed(Duration(seconds: 3), () => 'Delayed 3 seconds');
}

// Future.error
Future<String> futureError() => Future.error('Error message');

// 使用
futureDelayed()
  .then((i) => print(i))
  .catchError((e) => print(e))
  .whenComplete(() => print('Done'));
```

### Stream
```dart
import 'dart:async';

// 單一訂閱者
StreamController<String> controller = StreamController<String>();

void main() {
  controller.stream.listen(
    (data) => print(data),
    onError: (e) => print(e),
    onDone: () => print('Stream closed!')
  );

  controller.sink.add('Hello');
  controller.close();
}

// 廣播 (多訂閱者)
StreamController<String> controller = StreamController<String>.broadcast();
```

### 使用 async* 和 yield 產生 Stream
```dart
Stream<int> increaseStream() async* {
  for (int i = 1; i <= 10; i++) {
    await Future.delayed(Duration(seconds: 1));
    yield i;
  }
}

void main() {
  increaseStream().listen((event) => print(event));
}
```

### await for
```dart
Future<int> sumStream(Stream<int> stream) async {
  var sum = 0;
  await for (var i in stream) {
    sum += i;
  }
  return sum;
}
```

---

## 16. 並行處理 (Concurrency)

### Isolate
```dart
import 'dart:isolate';

void A(var msg) {
  print('Message: $msg');
}

void main() async {
  Isolate.spawn(A, 'Hello');
}
```

### 使用 Isolate.run 執行運算
```dart
int fibonacci(int n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

void main() async {
  final tasks = [
    () => fibonacci(40),
    () => fibonacci(41),
    () => fibonacci(42),
  ];

  final result = await Future.wait(tasks.map((i) => Isolate.run(i)));
  print('Result: $result');
}
```

---

## 17. Flutter 基礎

### 基本結構
```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MaterialApp(home: MyApp()));
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Title')),
      body: Center(child: Text('Hello World')),
    );
  }
}
```

### 顏色設定
```dart
Color(0xFFFFC000)              // Hex
Color.fromARGB(255, 255, 0, 0) // ARGB
Colors.green[400]              // Material Colors
```

### 常用 Widget
- `SafeArea` - 避免內容被系統 UI 遮擋
- `Container` - 容器，可設定大小、padding、margin
- `Column` / `Row` - 垂直/水平排列
- `Center` - 置中
- `Text` - 文字
- `ElevatedButton` - 按鈕
- `TextField` - 輸入框
- `Visibility` - 控制顯示/隱藏

### Container 寬度設定
```dart
Container(
  width: 200,                                    // 固定大小
  width: double.infinity,                        // 最大寬度
  width: MediaQuery.of(context).size.width * 0.8, // 螢幕 80%
)
```

### StreamBuilder
```dart
StreamBuilder(
  initialData: counter,
  stream: controller.stream,
  builder: (context, snapshot) {
    return Text('${snapshot.data}');
  },
)
```

---

## 重點整理

1. **Null Safety** 是 Dart 的重要特性，善用 `?`, `!`, `??`, `?.` 運算子
2. **const** vs **final**: const 是編譯期常數，final 是執行期常數
3. **List/Set/Map** 是最常用的資料結構
4. **extends** 繼承、**implements** 實作介面、**with** 混入 mixin
5. **async/await** 用於非同步程式設計
6. **Stream** 用於處理連續的非同步資料流
7. **Isolate** 用於並行處理，避免阻塞主執行緒
