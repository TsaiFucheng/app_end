# Dart 抽象類別、介面與 Mixin

> 課程日期：114/12/08
> 對應檔案：`1141208.txt`

---

## 教學重點

本次課程深入探討 Dart 的抽象類別、密封類別、介面與 Mixin，並介紹 `mixin on` 進階用法與動畫背景套件。

---

## 一、抽象類別 (Abstract Class)

- 使用 `abstract` 關鍵字定義
- **不能被實例化**
- 可以包含抽象方法 (無實作) 和具體方法 (有實作)
- 子類別必須實作所有抽象方法

### 基本用法

```dart
abstract class A {
  void say();    // 抽象方法
  void write();  // 抽象方法
}

class B extends A {
  @override
  void say() => print('B says');

  @override
  void write() => print('B writes');
}

void main() {
  B b = B();
  b.say();    // B says
  b.write();  // B writes
}
```

### 抽象類別包含具體方法

```dart
abstract class Animal {
  int? age;
  String? name;

  // 抽象方法：子類別必須實作
  void talk();

  // 具體方法：子類別可直接使用或覆寫
  void growl() => print('grrrr');
}

class Cat extends Animal {
  Cat(String name, int age) {
    this.name = name;
    this.age = age;
  }

  @override
  void talk() => print('Meow');
}

class Dog extends Animal {
  Dog(String name, int age) {
    this.name = name;
    this.age = age;
  }

  @override
  void talk() => print('Bark');
}

// 使用抽象類別作為參數型別 (多型)
void makeAnimalNoise(Animal a) => a.talk();

void main() {
  final cat = Cat('Nora', 5);
  final dog = Dog('Altera', 1);

  makeAnimalNoise(cat);  // Meow
  makeAnimalNoise(dog);  // Bark
  dog.growl();           // grrrr (繼承具體方法)
  cat.growl();           // grrrr
}
```

### Shape 範例

```dart
abstract class Shape {
  int getArea();                  // 抽象方法
  String getInfo() => 'Shape';    // 具體方法
}

class Rectangle extends Shape {
  @override
  getArea() => 100;
}

void main() {
  // final s = Shape();  // 錯誤！抽象類別不能被實例化
  final r = Rectangle();
  print(r.getArea());   // 100
  print(r.getInfo());   // Shape
}
```

---

## 二、密封類別 (Sealed Class)

- 類似抽象類別，但**只能在同一檔案中被繼承**
- 適合用於定義有限、已知的子類型集合
- 在 switch 中使用時，編譯器會檢查是否涵蓋所有狀態

### 基本用法

```dart
sealed class SealedStatus {
  void display() {}
}

class Init extends SealedStatus {
  @override
  void display() => print('The radio is initializing...');
}

class Playing extends SealedStatus {
  @override
  void display() => print('The radio is playing');
}

class Paused extends SealedStatus {
  @override
  void display() => print('The radio is paused');
}

class Stopped extends SealedStatus {
  @override
  void display() => print('The radio is stopped');
}

void main() {
  Init().display();     // The radio is initializing...
  Playing().display();  // The radio is playing
}
```

### 跨檔案限制

```dart
// seal.dart
sealed class A {
  fnA() {}
}

// main.dart
import 'seal.dart';

// 錯誤！sealed class 不能在其他檔案中被繼承
class B extends A {  // Error!
  @override
  fnA() => print('B');
}
```

### Flutter 狀態管理應用

```dart
sealed class ButtonState {
  ButtonState();
  factory ButtonState.loading() => LoadingButtonState();
  factory ButtonState.enabled() => EnabledButtonState();
  factory ButtonState.disabled() => DisabledButtonState();
}

class LoadingButtonState extends ButtonState {}
class EnabledButtonState extends ButtonState {}
class DisabledButtonState extends ButtonState {}

// switch 會自動檢查是否涵蓋所有狀態
Widget buildButton(ButtonState state) {
  switch (state) {
    case LoadingButtonState():
      return CircularProgressIndicator();
    case EnabledButtonState():
      return ElevatedButton(onPressed: () {}, child: Text('Click me'));
    case DisabledButtonState():
      return ElevatedButton(onPressed: null, child: Text('Disabled'));
  }
}
```

---

## 三、介面 (Interface)

Dart 沒有 `interface` 關鍵字，使用 `implements` 實作介面。

### 基本用法

```dart
abstract class A {
  fnA();
}

abstract class B {
  fnB();
}

// 一個類別可以實作多個介面
class C implements A, B {
  @override
  fnA() => print('A');

  @override
  fnB() => print('B');
}

void main() {
  final c1 = C();
  c1.fnA();  // A
  c1.fnB();  // B
}
```

### 使用一般類別作為介面

```dart
class C1 {
  total() {}
}

class C2 {
  discount() {}
}

// implements 必須覆寫所有方法
class C3 implements C1, C2 {
  @override
  total() => 1000;

  @override
  discount() => 50;
}

void main() {
  C3 c = C3();
  print('${c.total()} ${c.discount()}');  // 1000 50
}
```

### extends vs implements

```dart
class Runner {
  void running() => print('Run');
}

class Flyer {
  void flying() => print('Fly');
}

class SuperMan implements Runner, Flyer {
  @override
  void flying() {
    // super.flying();  // 錯誤！implements 不能使用 super
    print('SuperMan flying');
  }

  @override
  void running() {
    print('SuperMan running');
  }
}
```

---

## 四、Mixin

Mixin 用於在多個類別中重用程式碼，避免多重繼承的問題。

### 基本用法

```dart
class A {
  A() { print('Class A'); }
  a() => print('A');
}

mixin B {
  b() => print('B');
}

// 簡寫方式
class C = A with B;

// 完整方式
class D extends A with B {
  D() {
    a();
    print('D');
    super.b();  // 可以用 super 呼叫 mixin 方法
  }

  @override
  b() => print('BB');
}

void main() {
  C c1 = C();
  c1.a();  // A
  c1.b();  // B

  D d1 = D();  // Class A -> A -> D -> B
  d1.b();      // BB
}
```

### 實際應用：員工能力

```dart
class Employee {
  void clickIn() {}
}

mixin Medical {
  double takeTemperature() => 36.5;
}

// Nurse 和 Doctor 都有醫療能力
class Nurse extends Employee with Medical {}
class Doctor extends Employee with Medical {
  performSurgery() {}
}

// Bartender 沒有醫療能力
class Bartender extends Employee {}
```

### Mixin 優先順序

```dart
class Animal {
  void running() => print('Running');
}

mixin Runner {
  void running() => print('Running2');
}

mixin Flyer {
  void flying() => print('Flying');
}

// 後面的 mixin 會覆蓋前面的同名方法
class SuperMan extends Animal with Runner, Flyer {}

void main() {
  final sm = SuperMan();
  sm.running();  // Running2 (Runner 覆蓋了 Animal)
  sm.flying();   // Flying
}
```

### Mixin 方法優先順序範例

```dart
class A {
  void a() => print('fun a=> by a');
}

mixin C {
  void a() => print('fun a=> by c');
  void c() => print('fun c=> by c');
  void s() => print('fun s=> by c');
}

mixin E {
  String e = 'eee';
  void s() => print('fun s=> by e');
}

class D extends A with C, E {
  void c() => print('fun c=> by d');
}

void main() {
  D d1 = D();
  d1.a();  // fun a=> by c (C 覆蓋 A)
  d1.s();  // fun s=> by e (E 覆蓋 C)
  d1.c();  // fun c=> by d (D 覆蓋 C)
}
```

---

## 五、Mixin on 關鍵字 (進階)

`mixin on` 限制 mixin 只能被特定類別的子類別使用。

### 程式碼重用比較

**方式1：無重用 (重複程式碼)**
```dart
class Alligator {
  void swim() => print('Swim');
  void bite() => print('Chomp');
  void crawl() => print('Crawl');
  void hunt() {
    print('Alligator-----');
    swim(); crawl(); bite();
    print('Eat fish');
  }
}

class Crocodile {
  void swim() => print('Swim');
  void bite() => print('Chomp');
  void crawl() => print('Crawl');
  void hunt() {
    print('Crocodile-----');
    swim(); crawl(); bite();
    print('Eat fish');
  }
}
```

**方式2：使用抽象類別重用**
```dart
abstract class Reptile {
  void swim() => print('Swim');
  void bite() => print('Chomp');
  void crawl() => print('Crawl');
  void hunt(String food) {
    print('${this.runtimeType}-----');
    swim(); crawl(); bite();
    print('Eat $food');
  }
}

class Alligator extends Reptile {}
class Crocodile extends Reptile {}
```

**方式3：使用 Mixin 重用 (最靈活)**
```dart
mixin Swim {
  void swim() => print('Swim');
}

mixin Bite {
  void bite() => print('Chomp');
}

mixin Crawl {
  void crawl() => print('Crawl');
}

abstract class Reptile with Swim, Bite, Crawl {
  void hunt(String food) {
    print('${this.runtimeType}-----');
    swim(); crawl(); bite();
    print('Eat $food');
  }
}

class Alligator extends Reptile {}
class Crocodile extends Reptile {}

// Fish 只需要 Swim 和 Bite
class Fish with Swim, Bite {
  void feed() {
    print('Fish-----');
    swim(); bite();
  }
}
```

**方式4：使用 mixin on 限制**
```dart
mixin Swim {
  void swim() => print('Swim');
}

mixin Bite {
  void bite() => print('Chomp');
}

mixin Crawl {
  void crawl() => print('Crawl');
}

abstract class Reptile with Swim, Bite, Crawl {}

// Hunt mixin 只能用於 Reptile 的子類別
mixin Hunt on Reptile {
  void hunt(String food) {
    print('${this.runtimeType}-----');
    swim(); crawl(); bite();
    print('Eat $food');
  }
}

class Alligator extends Reptile with Hunt {}
class Crocodile extends Reptile with Hunt {}

// 錯誤！Hunt 只能用於 Reptile 的子類別
// class Fish with Swim, Bite, Hunt {}  // Error!

// 正確：Fish 繼承 Reptile 後才能使用 Hunt
class Fish extends Reptile with Hunt {
  void feed() {
    print('Fish-----');
    swim(); bite();
  }
}

void main() {
  Crocodile().hunt('Zebra');
  Alligator().hunt('Fish');
  Fish().hunt('small fish');
}
```

---

## 六、Flutter 動畫背景套件

### animated_background 套件使用

**安裝：**
```bash
flutter pub add animated_background
```

**使用 SingleTickerProviderStateMixin：**
```dart
class _Screen1State extends State<Screen1> with SingleTickerProviderStateMixin {

  var particles = ParticleOptions(
    baseColor: Colors.cyan,
    spawnOpacity: 0.0,
    minOpacity: 0.1,
    maxOpacity: 0.4,
    particleCount: 100,
    spawnMinSpeed: 30,
    spawnMaxSpeed: 100,
    spawnMinRadius: 7,
    spawnMaxRadius: 15,
  );

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: AnimatedBackground(
        behaviour: RandomParticleBehaviour(options: particles),
        vsync: this,  // 需要 SingleTickerProviderStateMixin
        child: Center(
          child: Text('Hello'),
        ),
      ),
    );
  }
}
```

---

## 繼承關係總覽

| 關鍵字 | 用途 | 數量限制 | 可使用 super |
|--------|------|----------|--------------|
| `extends` | 繼承類別 | 單一 | 可以 |
| `implements` | 實作介面 | 多個 | 不可 |
| `with` | 混入 Mixin | 多個 | 可以 |
| `on` | 限制 Mixin 使用範圍 | - | - |

### 組合使用

```dart
// 完整組合：繼承 + 混入 + 實作
class MyClass extends ParentClass with MixinA, MixinB implements InterfaceA, InterfaceB {
  // ...
}
```

---

## 學習要點總結

- [ ] 使用 `abstract class` 定義抽象類別和抽象方法
- [ ] 了解抽象類別不能被實例化
- [ ] 使用 `sealed class` 定義密封類別 (只能在同檔案繼承)
- [ ] 使用 `implements` 實作多個介面
- [ ] 了解 extends 和 implements 的差異
- [ ] 使用 `mixin` 定義可重用的程式碼區塊
- [ ] 使用 `with` 混入 mixin
- [ ] 使用 `mixin on` 限制 mixin 的使用範圍
- [ ] 了解 mixin 方法覆蓋的優先順序
- [ ] 使用 SingleTickerProviderStateMixin 搭配動畫
