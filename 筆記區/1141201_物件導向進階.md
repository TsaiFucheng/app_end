# Dart 物件導向進階與綜合複習

> 課程日期：114/12/01
> 對應檔案：`1141201.txt`

---

## 教學重點

本次課程為綜合複習，涵蓋 Dart 基礎到 OOP 進階內容。

---

## 一、建構子進階

### 1. 初始化列表 (Initializer List)

用於初始化 `final` 成員變數。

```dart
class Point {
  final sum, factor;
  Point(x, y) : sum = x + y, factor = x / y;
}

class Rectangle {
  final int width;
  final int height;
  final int area;
  // 初始化列表可使用其他參數計算
  Rectangle(this.width, this.height) : area = width * height;
}
```

**final 成員初始化方式：**
```dart
class Person {
  final String name;
  final int age;

  // 方式1：直接初始化
  Person(this.name, this.age);

  // 方式2：初始化列表
  Person.init(String n, int a) : name = n, age = a;

  // 方式3：具名參數 + 預設值
  Person.named({required this.name, this.age = 10});

  // 方式4：具名參數 + null 合併
  Person.nullable({String? name, int? age})
      : name = name ?? 'Unknown',
        age = age ?? 0;
}
```

### 2. 重定向建構子 (Redirecting Constructor)

```dart
class Point {
  double x, y;
  Point(this.x, this.y);

  // 重定向到主建構子
  Point.alongXAxis(double x) : this(x, 0);
  Point.alongYAxis(double y) : this(0, y);

  // 從初始化列表設定
  Point.internal(this.y) : x = 5;

  // 重定向到具名建構子
  Point.alongYAxis2(double y) : this.internal(y);
}

class Person {
  String name;
  int age;
  Person(String name) : this.internal(name, 0);
  Person.internal(this.name, this.age);
}

void main() {
  var p = Person('Ada');
  print(p.age);  // 0
}
```

### 3. 常數建構子 (Const Constructor)

```dart
class Student {
  final String name;
  final int age;
  const Student(this.name, this.age);
  Student.old(this.name, this.age);  // 非常數建構子
}

void main() {
  // 使用 const 建立相同值的物件會是同一個實例
  const s1 = Student('Ada', 22);
  const s2 = Student('Ada', 22);
  print(identical(s1, s2));  // true

  // 不使用 const 則是不同實例
  var s3 = Student('Ada', 22);
  var s4 = Student('Ada', 22);
  print(identical(s3, s4));  // false
}
```

### 4. 工廠建構子 (Factory Constructor)

```dart
class Person {
  String name;
  String color;
  static final Map<String, Person> _nameCache = {};

  Person(this.name, this.color);

  // 工廠建構子：實作快取機制
  factory Person.withName(String name) {
    if (_nameCache.containsKey(name)) {
      return _nameCache[name]!;
    } else {
      final p = Person(name, 'default');
      _nameCache[name] = p;
      return p;
    }
  }
}

void main() {
  final p1 = Person.withName('Ada');
  final p2 = Person.withName('Ada');
  print(identical(p1, p2));  // true (回傳同一個快取實例)
}
```

**工廠建構子回傳子類別：**
```dart
class Dog {
  String name;
  Dog(this.name);

  factory Dog.createDog({required String name, bool guardDog = false}) {
    if (guardDog)
      return Doberman(name);
    else
      return Labrador(name);
  }
}

class Doberman extends Dog {
  Doberman(String name) : super(name);
}

class Labrador extends Dog {
  Labrador(String name) : super(name);
}
```

---

## 二、單例模式 (Singleton)

### 方式1：使用 static 方法

```dart
class Singleton1 {
  static Singleton1? _instance;

  Singleton1._internal();

  static Singleton1 getInstance() {
    _instance ??= Singleton1._internal();
    return _instance!;
  }
}

var s1 = Singleton1.getInstance();
```

### 方式2：使用 getter

```dart
class Singleton2 {
  static Singleton2? _instance;

  Singleton2._internal();

  static Singleton2 get instance {
    _instance ??= Singleton2._internal();
    return _instance!;
  }
}

var s2 = Singleton2.instance;
```

### 方式3：使用 factory (推薦)

```dart
class Singleton3 {
  static Singleton3? _instance;

  Singleton3._internal();

  factory Singleton3() => _instance ??= Singleton3._internal();
}

var s3 = Singleton3();
```

### 方式4：使用 static final

```dart
class Singleton4 {
  static final Singleton4 _instance = Singleton4._internal();

  Singleton4._internal();

  factory Singleton4() => _instance;
}

void main() {
  var s1 = Singleton4();
  var s2 = Singleton4();
  print(identical(s1, s2));  // true
}
```

---

## 三、運算子重載 (Operator Overloading)

**可重載的運算子：** `+`, `-`, `*`, `/`, `%`, `^`, `~/`, `>`, `<`, `>=`, `<=`, `>>`, `<<`, `&`, `|`, `[]`, `~`

```dart
class Vector {
  num x, y;
  Vector(this.x, this.y);

  // 重載 + 運算子
  operator +(Vector v) => Vector(x + v.x, y + v.y);

  // 重載 - 運算子
  operator -(Vector v) => Vector(x - v.x, y - v.y);

  printVec() => print('x:$x, y:$y');
}

void main() {
  Vector v1 = Vector(1, 2);
  Vector v2 = Vector(3, 4);
  (v1 + v2).printVec();  // x:4, y:6
  (v2 - v1).printVec();  // x:2, y:2
}
```

---

## 四、抽象類別 (Abstract Class)

抽象類別不能被實例化，用於定義介面和共同行為。

```dart
abstract class Animal {
  int? age;
  String? name;

  // 抽象方法 (無實作)
  void talk();

  // 具體方法 (有實作)
  void growl() => print('grrrr');
}

class Cat extends Animal {
  Cat(String name, int age) {
    this.name = name;
    this.age = age;
  }

  @override
  void talk() => print('Meow');
}

class Dog extends Animal {
  Dog(String name, int age) {
    this.name = name;
    this.age = age;
  }

  @override
  void talk() => print('Bark');
}

void makeAnimalNoise(Animal a) => a.talk();

void main() {
  final cat = Cat('Nora', 5);
  final dog = Dog('Altera', 1);
  makeAnimalNoise(cat);  // Meow
  makeAnimalNoise(dog);  // Bark
  dog.growl();           // grrrr (繼承具體方法)
}
```

---

## 五、密封類別 (Sealed Class)

- 類似抽象類別，但只能在同一檔案中被繼承
- 適合用於有限狀態的表示

```dart
sealed class SealedStatus {
  void display() {}
}

class Init extends SealedStatus {
  @override
  void display() => print('The radio is initializing...');
}

class Playing extends SealedStatus {
  @override
  void display() => print('The radio is playing');
}

class Paused extends SealedStatus {
  @override
  void display() => print('The radio is paused');
}

class Stopped extends SealedStatus {
  @override
  void display() => print('The radio is stopped');
}

void main() {
  Init().display();      // The radio is initializing...
  Playing().display();   // The radio is playing
}
```

**Sealed Class 在 Flutter 中的應用：**
```dart
sealed class ButtonState {
  ButtonState();
  factory ButtonState.loading() => LoadingButtonState();
  factory ButtonState.enabled() => EnabledButtonState();
  factory ButtonState.disabled() => DisabledButtonState();
}

class LoadingButtonState extends ButtonState {}
class EnabledButtonState extends ButtonState {}
class DisabledButtonState extends ButtonState {}

// 在 switch 中使用時，編譯器會檢查是否涵蓋所有狀態
Widget buildButton(ButtonState state) {
  switch (state) {
    case LoadingButtonState(): return CircularProgressIndicator();
    case EnabledButtonState(): return ElevatedButton(onPressed: () {}, child: Text('Click'));
    case DisabledButtonState(): return ElevatedButton(onPressed: null, child: Text('Disabled'));
  }
}
```

---

## 六、介面 (Interface)

Dart 使用 `implements` 實作多個介面，必須覆寫所有方法。

```dart
abstract class A {
  fnA();
}

abstract class B {
  fnB();
}

// implements 實作多個介面
class C implements A, B {
  @override
  fnA() => print('A');

  @override
  fnB() => print('B');
}

void main() {
  final c1 = C();
  c1.fnA();  // A
  c1.fnB();  // B
}
```

**extends vs implements：**
```dart
class Runner {
  void running() => print('Run');
}

class Flyer {
  void flying() => print('Fly');
}

// implements 無法使用 super 呼叫父類別方法
class SuperMan implements Runner, Flyer {
  @override
  void flying() {
    // super.flying();  // 錯誤！
    print('SuperMan flying');
  }

  @override
  void running() {
    print('SuperMan running');
  }
}
```

---

## 七、Mixins

Mixin 用於在多個類別中重用程式碼，無需繼承。

```dart
class A {
  a() => print('A');
}

mixin B {
  b() => print('B');
}

// 使用 with 混入
class C = A with B;  // 簡寫方式

class D extends A with B {
  D() {
    a();
    b();
  }
}

void main() {
  C c1 = C();
  c1.a();  // A
  c1.b();  // B
}
```

**實際應用範例：**
```dart
class Employee {
  void clickIn() {}
}

mixin Medical {
  double takeTemperature() => 36.5;
}

// Nurse 和 Doctor 都能測量體溫
class Nurse extends Employee with Medical {}
class Doctor extends Employee with Medical {
  performSurgery() {}
}

// Bartender 沒有醫療能力
class Bartender extends Employee {}
```

**多個 Mixin 的優先順序：**
```dart
class Animal {
  void running() => print('Running');
}

mixin Runner {
  void running() => print('Running2');
}

mixin Flyer {
  void flying() => print('Flying');
}

// Mixin 順序：後面的會覆蓋前面的同名方法
class SuperMan extends Animal with Runner, Flyer {}

void main() {
  final sm = SuperMan();
  sm.running();  // Running2 (Runner 覆蓋了 Animal)
  sm.flying();   // Flying
}
```

**綜合範例：**
```dart
abstract class Animal {
  String name;
  Animal(this.name);
  String get noise;
  String eat() => 'Eat something';
}

class Bird extends Animal {
  Bird(String name) : super(name);
  String get noise => 'Tweet';
}

mixin Swimmer {
  String swim() => 'can swim';
}

mixin Flyer {
  String fly() => 'can fly';
}

// Duck 繼承 Bird，混入 Swimmer 和 Flyer
class Duck extends Bird with Swimmer, Flyer {
  Duck(String name) : super(name);
  String get noise => 'duckling';
}

void main() {
  var duck = Duck('Bufflehead');
  print('${duck.name} ${duck.noise}, ${duck.eat()}, ${duck.swim()}, ${duck.fly()}');
  // Bufflehead duckling, Eat something, can swim, can fly
}
```

---

## 八、列舉 (Enumeration)

```dart
enum Colors { red, green, blue }

void main() {
  final color = Colors.red;

  switch (color) {
    case Colors.red: print('Red'); break;
    case Colors.green: print('Green'); break;
    case Colors.blue: print('Blue'); break;
  }

  print(Colors.values);      // [Colors.red, Colors.green, Colors.blue]
  print(Colors.values[0]);   // Colors.red
  print(Colors.red.index);   // 0
}
```

---

## 繼承關係總覽

| 關鍵字 | 用途 | 特點 |
|--------|------|------|
| `extends` | 繼承類別 | 單一繼承，可使用 super |
| `implements` | 實作介面 | 可多重實作，須覆寫所有方法 |
| `with` | 混入 Mixin | 可多重混入，用於程式碼重用 |

```dart
// 綜合使用
class MyClass extends ParentClass with MixinA, MixinB implements InterfaceA, InterfaceB {
  // ...
}
```

---

## 學習要點總結

- [ ] 使用初始化列表初始化 `final` 成員
- [ ] 使用 `: this()` 建立重定向建構子
- [ ] 使用 `const` 建構子建立編譯時常數物件
- [ ] 使用 `factory` 建構子實作快取或回傳子類別
- [ ] 實作單例模式的四種方式
- [ ] 使用 `operator` 關鍵字重載運算子
- [ ] 使用 `abstract class` 定義抽象類別
- [ ] 使用 `sealed class` 定義密封類別
- [ ] 使用 `implements` 實作多個介面
- [ ] 使用 `mixin` 和 `with` 實現程式碼重用
- [ ] 了解 extends、implements、with 的差異
