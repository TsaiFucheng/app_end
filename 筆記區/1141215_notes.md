# Dart & Flutter 課程筆記 (1141215)

## 目錄
1. [字串處理](#1-字串處理)
2. [變數與型別](#2-變數與型別)
3. [集合型別](#3-集合型別)
4. [Null Safety](#4-null-safety)
5. [Runes (Unicode)](#5-runes-unicode)
6. [運算子](#6-運算子)
7. [控制流程](#7-控制流程)
8. [異常處理](#8-異常處理)
9. [函數與方法](#9-函數與方法)
10. [遞迴](#10-遞迴)
11. [物件導向程式設計 (OOP)](#11-物件導向程式設計-oop)
12. [建構子進階](#12-建構子進階)
13. [抽象類別與介面](#13-抽象類別與介面)
14. [Mixins](#14-mixins)
15. [泛型 (Generics)](#15-泛型-generics)
16. [函式庫 (Library)](#16-函式庫-library)
17. [非同步程式設計](#17-非同步程式設計)
18. [並行處理 (Concurrency)](#18-並行處理-concurrency)
19. [Flutter 基礎](#19-flutter-基礎)

---

## 1. 字串處理

### 正規表達式 (Regular Expression)
```dart
String s01 = "abc1defg2hijk";
var list1 = s01.split(RegExp(r"\d"));
print(list1);  // [abc, defg, hijk]
```

### StringBuffer
```dart
StringBuffer s02 = StringBuffer();
s02.writeln('Test');        // 寫入並換行
s02.writeAll(['x','y','z']); // 寫入多個元素
s02.write(100);              // 寫入單一值
s02.writeCharCode(65);       // 寫入字元碼 (A)
print(s02);
```

### 數字/字串轉換
```dart
var int1 = int.parse("123");           // 字串轉整數
var double1 = double.parse("33.3");    // 字串轉浮點數
String str1 = x.toString();            // 數字轉字串
String str2 = pi.toStringAsFixed(2);   // 浮點數轉字串 (指定小數位)
```

---

## 2. 變數與型別

### 變數宣告方式比較

| 宣告方式 | 特性 |
|---------|------|
| `var` | 自動推論型別，一旦賦值後型別固定 |
| `dynamic` | 可隨時改變型別 |
| `const` | 編譯期常數，必須在宣告時賦值 |
| `final` | 執行期常數，只能賦值一次 |

### 範例
```dart
var pi2 = 3.14159;     // 自動推論為 double，之後不能改為其他型別
dynamic pi3 = 3.14159;  // 可以改變型別
pi3 = "3.14159";        // OK

const pi5 = 3.14159;    // 編譯期常數
final name = 'Bob';     // 執行期常數，只能賦值一次

// num 型別可以是 int 或 double
num pi6 = 3;
pi6 = 3.14;  // OK
```

---

## 3. 集合型別

### List (有序陣列)
```dart
var list1 = [1, 2, 3];              // List<int>
List list2 = [1, 2, 3];             // List<dynamic>
List<int> list3 = [1, 2, 3];        // 明確宣告型別
var list4 = List.filled(3, 0);      // 建立固定長度的 List
var constantList = const [1, 2, 3]; // 常數 List (不可修改)

// 常用操作
list1.add(4);                       // 新增元素
list1.remove(4);                    // 移除元素
list1.contains(2);                  // 檢查是否包含
list1.reversed;                     // 反轉 (回傳 Iterable)
list1.sort();                       // 排序
list1.shuffle();                    // 隨機排序

// 二維陣列
List<List<int>> matrix = [[1,2,3], [4,5,6]];
print(matrix[0][1]);  // 2

// 過濾
var n = [1, 2, 3, 4, 5];
n.where((i) => i.isOdd).forEach((i) => print(i));  // 1 3 5
```

### Set (無序不重複集合)
```dart
var set1 = {1, 2, 3};           // Set<int>
var set3 = <int>{};             // 空的 Set<int>

// 集合操作
set1.difference(set2);   // 差集
set1.intersection(set2); // 交集
set1.union(set2);        // 聯集

// 轉換為 List
List x = set1.toList();
```

### Map (鍵值對)
```dart
var g1 = {'first': 'A', 'second': 'B'};
var g2 = Map();
g2['first'] = 'A';

// 常用操作
g1['third'] = 'C';      // 新增
print(g1['first']);      // 取值
m1.addAll(m2);          // 合併

// 遍歷
g1.forEach((k, v) => print('Key:$k, value:$v'));
```

### Collections (Queue)
```dart
import 'dart:collection';

Queue q1 = Queue();
q1.addAll([10, 20, 30]);
```

---

## 4. Null Safety

### 基本概念
```dart
int x;       // x 是 non-nullable
int? y;      // y 是 nullable (可以是 null)

// x = null;   // 錯誤！
y = null;      // OK

// 使用前必須確保有值
x = 100;
print(x);

// nullable 轉 non-nullable
x = y!;  // 使用 ! 進行 null check
```

### 類別中的 Null Safety
```dart
class A {
  int? a;      // nullable
  late int aa; // 延遲初始化
}
```

### Null 檢查與預設值
```dart
String? value1;
print(value1?.toLowerCase());  // null-aware access

// ?? 運算子
var result = user ?? "root";  // 如果 user 是 null，使用 "root"

// ??= 運算子
k ??= 5;  // 如果 k 是 null，賦值為 5
```

---

## 5. Runes (Unicode)

```dart
Runes heart = Runes('\u2665');
Runes laugh = Runes('\u{1f600}');
print(String.fromCharCodes(heart));  // ♥

String greeting = '\u4f60\u597d';    // 你好
print(greeting);
```

---

## 6. 運算子

### 運算子類型

| 類型 | 運算子 |
|------|--------|
| 邏輯運算 | `\|\|` (OR), `&&` (AND), `!` (NOT) |
| 位元運算 | `&`, `\|`, `^`, `~`, `<<`, `>>` |
| 算術運算 | `+`, `-`, `*`, `/`, `~/` (整數除法), `%` |
| 比較運算 | `>`, `<`, `>=`, `<=`, `==`, `!=` |
| 型別檢查 | `is`, `is!` |
| 指派運算 | `=`, `??=`, `+=`, `-=`, `*=`, `/=` |

### 特殊運算子
```dart
// 條件運算子
condition ? expr1 : expr2;

// Null 合併運算子
expr1 ?? expr2;  // 如果 expr1 為 null，回傳 expr2

// Spread 運算子
var list3 = [0, ...list1];

// Null-aware spread
var myFriend = [...friendA, ...?friendB];

// 串接運算子
var student = Student()
  ..id = 1
  ..name = 'Andy'
  ..Greeting();
```

### 型別轉換與檢查
```dart
Object s1 = 'Hello';
String myString = s1 as String;  // 強制轉型

if (s1 is String) print('是字串');
if (s1 is! int) print('不是整數');
```

---

## 7. 控制流程

### 條件判斷
```dart
// if-else
if (score < 60) {
  print("不及格");
} else if (score < 80) {
  print("普通");
} else {
  print("優秀");
}

// switch
switch (command) {
  case 'CLOSED': print("關閉"); break;
  case 'OPEN': print("開啟"); break;
  default: print('未知');
}
```

### 迴圈
```dart
// for 迴圈
for (int x = 0; x < 5; x++) print(x);

// for-in 迴圈
for (var j in list) print(j);

// forEach
list.forEach((i) => print(i));

// while
while (k <= 10) { sum += k; k++; }

// do-while
do { print(x); } while (x < 5);
```

### 標準輸入輸出
```dart
import 'dart:io';

stdout.write('請輸入: ');
var input = stdin.readLineSync()!;
```

---

## 8. 異常處理

### 基本語法
```dart
try {
  // 可能發生錯誤的程式碼
} catch (e) {
  print(e);
} finally {
  print('一定會執行');
}
```

### 自訂例外
```dart
class AmountException implements Exception {
  String? s1;
  AmountException(String s) { print('$s'); }
}

void withDraw(int amount) {
  if (amount < 0) {
    throw AmountException('金額不可為負!');
  }
}

// 使用 on 捕捉特定例外
try {
  withDraw(-200);
} on AmountException {
  print('處理金額例外');
}
```

---

## 9. 函數與方法

### 函數宣告方式
```dart
// 完整宣告
int add1(int a, int b) { return a + b; }

// 箭頭函數
int add2(a, b) => a + b;

// 無型別宣告
add3(a, b) => a + b;
```

### 可選參數
```dart
// 位置可選參數 (用 [])
void p3(int a, int b, [int c = 99]) => print(a + b + c);

// 命名可選參數 (用 {})
void p4(int a, int b, {int c = 99}) => print(a + b + c);
p4(1, 2, c: 3);

// required 必填參數
sayHello({required String name}) => print("Hello, $name");
```

### 函數作為參數
```dart
void test(Function fool) {
  fool();
}

test(() => print('Hello'));
```

### typedef
```dart
typedef Calculate = int Function(int n1, int n2);

int compute(Calculate calc) {
  return calc(20, 30);
}

var result = compute((n1, n2) => n1 + n2);  // 50
```

---

## 10. 遞迴

```dart
// 階乘
int Fact(int n) {
  if (n <= 1) return 1;
  return n * Fact(n - 1);
}

// 費氏數列
int Fib(int n) {
  if (n <= 1) return n;
  return Fib(n - 1) + Fib(n - 2);
}
```

---

## 11. 物件導向程式設計 (OOP)

### 類別基本結構
```dart
class Circle {
  final pi = 3.14159;
  int r = 0;

  Circle(int q) { r = q; }  // 建構子

  int area() => r * r;
  double vol() => 4/3 * r * r * r;
}

var c1 = Circle(5);
print(c1.area());
```

### 私有成員 (Private)
```dart
// car.dart
class Car {
  late int _a;  // 私有成員 (底線開頭)

  set setA(v) => _a = v;
  int get getA => _a;
}
```

### Getter / Setter
```dart
class Rect {
  num height, width;
  Rect(this.height, this.width);

  get area => height * width;
  set areaHeight(v) => height = v;
}
```

### 類別繼承
```dart
class Animal {
  void eat() => print('Animal can eat.');
}

class Dog extends Animal {
  @override
  void eat() => print('Dog can eat.');

  void eat1() {
    this.eat();   // 呼叫自己的 eat
    super.eat();  // 呼叫父類別的 eat
  }
}
```

---

## 12. 建構子進階

### Named Constructor (命名建構子)
```dart
class Cat {
  late String name, color;

  Cat(this.name, this.color);
  Cat.orange(this.name) { color = 'Orange'; }
  Cat.black(this.name) { color = 'Black'; }
  Cat.fromJson(Map<String, dynamic> json) {
    name = json['name'];
    color = json['color'];
  }
}

var cat1 = Cat.orange('Nora');
var cat2 = Cat.fromJson({'name': 'Kitty', 'color': 'White'});
```

### 初始化列表 (Initializer List)
```dart
class Point {
  final sum, factor;
  Point(x, y) : sum = x + y, factor = x / y;
}

class Rectangle {
  final int width, height, area;
  Rectangle(this.width, this.height) : area = width * height;
}
```

### Redirecting Constructor
```dart
class Point {
  double x, y;
  Point(this.x, this.y);
  Point.alongXAxis(double x) : this(x, 0);  // 重定向
}
```

### Constant Constructor
```dart
class Student {
  final String name;
  final int age;
  const Student(this.name, this.age);
}

const s1 = Student('Ada', 22);
const s2 = Student('Ada', 22);
print(identical(s1, s2));  // true (同一個實例)
```

### Factory Constructor
```dart
class Person {
  String name;
  static final Map<String, Person> _cache = {};

  Person(this.name);

  factory Person.withName(String name) {
    return _cache.putIfAbsent(name, () => Person(name));
  }
}
```

### Singleton 模式
```dart
class S {
  static final S _instance = S._internal();
  S._internal();
  factory S() => _instance;
}

var s1 = S();
var s2 = S();
print(identical(s1, s2));  // true
```

---

## 13. 抽象類別與介面

### 抽象類別 (Abstract Class)
```dart
abstract class Animal {
  int? age;
  void talk();  // 抽象方法
  void growl() => print('grrrr');  // 一般方法
}

class Cat extends Animal {
  @override
  void talk() => print('Meow');
}
```

### Sealed Class
```dart
sealed class SealedStatus {
  void display() {}
}

class Playing extends SealedStatus {
  @override
  void display() => print('Playing');
}
```
- 類似抽象類別
- 只能在同一個檔案中被繼承

### Interface (介面)
```dart
abstract class A { fnA(); }
abstract class B { fnB(); }

class C implements A, B {
  @override
  fnA() => print('A');
  @override
  fnB() => print('B');
}
```

---

## 14. Mixins

### 基本用法
```dart
mixin Swimmer {
  String swim() => 'can swim';
}

mixin Flyer {
  String fly() => 'can fly';
}

class Duck extends Bird with Swimmer, Flyer {}
```

### mixin on (限制使用範圍)
```dart
abstract class Reptile with Swim, Bite, Crawl {}

mixin Hunt on Reptile {
  void hunt(String food) {
    swim();
    crawl();
    bite();
    print('Eat $food');
  }
}

class Alligator extends Reptile with Hunt {}
```

---

## 15. 泛型 (Generics)

### 泛型類別
```dart
class Pair<T> {
  T x, y;
  Pair(this.x, this.y);
}

var p1 = Pair<int>(10, 20);
var p2 = Pair<String>('A', 'B');
```

### 泛型限制
```dart
class Point<T extends num> {
  T x, y;
  Point(this.x, this.y);
}
```

### 泛型函數
```dart
T printFirst<T>(List<T> lst) {
  T first = lst[0];
  print(first);
  return first;
}
```

---

## 16. 函式庫 (Library)

### 匯入函式庫
```dart
import 'dart:math';                    // 系統函式庫
import './utils/util.dart';            // 自訂函式庫
import './math_util.dart' as mUtil;    // 使用別名
import './util.dart' show sum;         // 只匯入 sum
import './util.dart' hide sum;         // 排除 sum
```

### 匯出多個檔案
```dart
// utils/utils.dart
export 'math1.dart';
export 'math2.dart';
export 'math3.dart';
```

---

## 17. 非同步程式設計

### async / await
```dart
Future<String> getData() async {
  var response = await http.get(Uri.parse(url));
  return response.body;
}

void main() async {
  var data = await getData();
  print(data);
}
```

### Future
```dart
// Future.value
Future<int> futureWait() => Future.value(10);

// Future.delayed
Future<String> futureDelayed() {
  return Future.delayed(Duration(seconds: 3), () => 'Done');
}

// Future.error
Future<String> futureError() => Future.error('Error!');

// 串接處理
futureWait()
  .then((i) => print(i))
  .catchError((e) => print(e))
  .whenComplete(() => print('Done'));
```

### Stream
```dart
import 'dart:async';

// 單一訂閱者
StreamController<String> controller = StreamController<String>();
controller.stream.listen(
  (data) => print(data),
  onError: (e) => print(e),
  onDone: () => print('Done')
);
controller.sink.add('Hello');
controller.close();

// 廣播 (多訂閱者)
StreamController<String> controller = StreamController<String>.broadcast();
```

### 使用 async* 和 yield 產生 Stream
```dart
Stream<int> increaseStream() async* {
  for (int i = 1; i <= 10; i++) {
    await Future.delayed(Duration(seconds: 1));
    yield i;
  }
}
```

### StreamBuilder (Flutter)
```dart
StreamBuilder(
  stream: controller.stream,
  builder: (context, snapshot) {
    return Text('${snapshot.data}');
  },
)
```

---

## 18. 並行處理 (Concurrency)

### Isolate
```dart
import 'dart:isolate';

void heavyTask(var msg) {
  print('Executing: $msg');
}

void main() async {
  await Isolate.spawn(heavyTask, 'Hello');
  print('Main continues...');
}
```

### 使用 Isolate.run 執行運算
```dart
int fibonacci(int n) {
  if (n <= 1) return n;
  return fibonacci(n-1) + fibonacci(n-2);
}

void main() async {
  final tasks = [
    () => fibonacci(40),
    () => fibonacci(41),
    () => fibonacci(42),
  ];

  final result = await Future.wait(tasks.map((i) => Isolate.run(i)));
  print('Result: $result');
}
```

---

## 19. Flutter 基礎

### 基本結構
```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MaterialApp(home: MyApp()));
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('標題')),
      body: Center(child: Text('Hello')),
    );
  }
}
```

### 顏色設定
```dart
Color(0xFFFFC000)              // 16進位
Color.fromARGB(255, 255, 0, 0) // ARGB
Colors.green[400]              // Material 顏色
```

### Container 寬度設定
```dart
Container(
  width: 200,                                    // 固定寬度
  width: double.infinity,                        // 填滿
  width: MediaQuery.of(context).size.width * 0.8, // 螢幕寬度的 80%
)
```

### SafeArea
```dart
SafeArea(
  child: Column(children: [...]),
)
```

### StatefulWidget 與 setState
```dart
class MyHomePage extends StatefulWidget {
  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  int count = 0;

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: () {
        setState(() { count++; });
      },
      child: Text('Count: $count'),
    );
  }
}
```

### 佈局 Widget
- **Row**: 水平排列
- **Column**: 垂直排列
- **Stack**: 堆疊排列
- **Wrap**: 自動換行
- **Expanded**: 填滿剩餘空間

### 常用套件
```dart
// 動畫背景
import 'package:animated_background/animated_background.dart';

// 滑動操作
import 'package:flutter_slidable/flutter_slidable.dart';

// 日期格式
import 'package:intl/intl.dart';

// 模糊效果
import 'package:blur/blur.dart';
```

---

## 學習重點總結

1. **型別系統**: 理解 `var`, `dynamic`, `const`, `final` 的差異
2. **Null Safety**: 善用 `?`, `!`, `??`, `?.` 處理空值
3. **集合操作**: 熟練 List, Set, Map 的各種方法
4. **OOP**: 掌握繼承、介面、Mixins 的使用時機
5. **建構子**: 了解各種建構子的用途 (Named, Factory, Const)
6. **非同步**: 熟悉 async/await, Future, Stream 的使用
7. **Flutter**: 理解 StatelessWidget 與 StatefulWidget 的差異
